# 1 DFS
- **LeetCode定义**  
深度优先搜索算法是一种用于遍历或搜索**树**或**图**的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当前节点v的所有边都已被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点。如果还存在未发现的节点，则选择其中一个节点作为源节点并重复以上过程，整个遍历进程反复进行直到所以节点都被访问到为止。
- **算法框架**  
```c++
/* 遍历树，递归实现 */
void dfs(TreeNode *node){
    // 1.触底返回
    if (node == nullptr) {
        return;
    }
    // 2.处理当前节点
    /* 常见做法：a.检查当前节点值; b.记录路径; */

    // 3.继续深入遍历
    dfs(node->left);
    dfs(node->right);
}

/* 遍历树，栈实现 */
void dfs(TreeNode *node) {
    // node判空
    stack<TreeNode*> st;

    // 1.根节点入栈
    st.push(root);
    while (!st.empty()){
        TreeNode *node = st.top();
        if (node->left == nullptr && node->right == nullptr){
            // 2.当前节点为叶子节点，处理完叶子节点之后出栈
            node->val ....
            st.pop();
        }
        // 3.非叶子节点，将节点入栈，继续深入遍历
        if (node->left != nullptr){
            st.push(st->left);
        }
        if (node->right != nullptr){
            st.push(st->right);
        }
    }

}

/* 遍历图（矩阵），递归实现 */
void dfs(vector<vector<int>>& matrix, int i, int j){
    // 1.如果已经访问，返回
    if (isVisted(matrix[i][j])) {
        return;
    }

    // 2.将当前节点设置成已访问状态
    visted(matrix[i][j]);

    // 3.继续遍历周边节点
    for(auto ni, nj : dir[]){
        dfs(matrix, i+ni, j+nj);
    }

}
```

```python

```
- 常见题型1--二叉树遍历
- 常见题型2--矩阵遍历
- 常见题型3--图的遍历

# 2 BFS